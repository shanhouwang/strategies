// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Peter_O

//@version=5
strategy('Momentum-based ZigZag + 趋势', shorttitle="Momentum-based ZigZag + 趋势", overlay=true, precision=2, pyramiding=1, 
 calc_on_every_tick=true, backtest_fill_limits_assumption=1, default_qty_type=strategy.percent_of_equity, default_qty_value = 50, currency=currency.USD, slippage=1, commission_type=strategy.commission.percent,
 commission_value=.03, process_orders_on_close=true, initial_capital=10000, margin_long=100, margin_short=100)

lowest = input(5, title='多少根K线参与计算')
RRR = input(3, title='盈亏比')

longOn = input.bool(true , '是否开启多单')
shortOn = input.bool(true , '是否开启空单')

trendOn = input.bool(true , '是否开启趋势线')

emaNo = input(200, title='ema参数')
long_Ts2          = input.float(0.004,          title='long移动止盈参数',     minval=0,       step=0.001)
short_Ts2          = input.float(0.002,          title='short移动止盈参数',     minval=0,       step=0.001)

var int momentum_direction = 0
color_zigzag_lines = input(true, title='Color ZigZag lines to show force direction')
momentum_select = input.string(title='Select Momentum Indicator:', defval='QQE', options=['MACD', 'MovingAverage', 'QQE'])

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// Input: RSI-QQE ZigZag
r1_type = input.string("Wilders", title = "Rsi-Type", options = ["Cutlers", "Wilders"], group = "ZigZag", inline = "R_0", tooltip = 'Choose between Cutlers and Wilders RSI')

r1_len = input.int(14, title = "Rsi-Len", group = "ZigZag", inline = "R_2")
r1_mtf = input.int(2, title = "Mtf-Mult", group = "ZigZag", inline = "R_2", tooltip = "==> Rsi-Len: Set the Length for the RSI\n==> Mtf-Mult: Length Multiplier for RSI to get MTF Resolution")

r1_mult = input.float(3, title = "QQe-Mult", group = "ZigZag", inline = "Q_1")
r1_smooth = input.int(1, title = "Smooth", group = "ZigZag", inline = "Q_1", tooltip = "==> QQE-Mult: Set the distance between QQE and RSI (works similar like Supertrend Mult)\n==> Rsi-Smooth: Smooth the Rsi with EMA")
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// Input: Supertrend
s1_show = input.bool(true, title = "Show-Supertrend", group = "Supertrend", inline = "S_00")

s1_len = input.int(34, title = "Ma-Len", group = "Supertrend", inline = "S_1")
s1_type = input.string("EMA", title = "Ma-Type", options = ["SMA", "EMA", "HH / LL"], group = "Supertrend", inline = "S_1", tooltip = "==> MA-Len: Set the Length for the Base of the Supertend\n==> MA-Type: Choose the Base Type for the Supertrend")

s1_atr_len = input.int(34, title = "Atr-Len", group = "Supertrend", inline = "S_2")
s1_atr_mult = input.float(4.25, title = "Atr-Mult", group = "Supertrend", inline = "S_2", tooltip = "==> Atr-Len: Set the Length for the Atr\n==> Atr:Mult: Set the Multiplier for the ATR")

s1_incl = input.bool(true, title = "Include-ZigZag", group = "Supertrend", inline = "S_0", tooltip = "Wanna include the ZigZag in the Supertrend calculation?")

s1_bull = input.color(color.green, title = "UpTrend", group = "Supertrend", inline = "S_3")
s1_bear = input.color(color.red, title = "DownTrend", group = "Supertrend", inline = "S_3")
s1_line = input.int(1, title = "Line", group = "Supertrend", inline = "S_3")

// ZigZag function {
zigzag(_momentum_direction) =>
    zz_goingup = _momentum_direction == 1
    zz_goingdown = _momentum_direction == -1
    var float zz_peak = na
    var float zz_bottom = na
    zz_peak := high > zz_peak[1] and zz_goingup or zz_goingdown[1] and zz_goingup ? high : nz(zz_peak[1])
    zz_bottom := low < zz_bottom[1] and zz_goingdown or zz_goingup[1] and zz_goingdown ? low : nz(zz_bottom[1])
    zigzag = zz_goingup and zz_goingdown[1] ? zz_bottom[1] : zz_goingup[1] and zz_goingdown ? zz_peak[1] : na
    zigzag
// } End of ZigZag function

// MACD  {
fast_length = input.int(title='Fast Length', defval=12, group='if MACD Selected', inline='macd')
slow_length = input.int(title='Slow Length', defval=26, group='if MACD Selected', inline='macd')
src = input.source(title='Source', defval=close, group='if MACD Selected', inline='macd')
signal_length = input.int(title='Signal Smoothing', minval=1, maxval=50, defval=9, group='if MACD Selected', inline='macd')
sma_source = input.string(title='Oscillator MA Type', defval='EMA', options=['SMA', 'EMA'], group='if MACD Selected', inline='macd')
sma_signal = input.string(title='Signal Line MA Type', defval='EMA', options=['SMA', 'EMA'], group='if MACD Selected', inline='macd')

fast_ma = sma_source == 'SMA' ? ta.sma(src, fast_length) : ta.ema(src, fast_length)
slow_ma = sma_source == 'SMA' ? ta.sma(src, slow_length) : ta.ema(src, slow_length)
macd = fast_ma - slow_ma
signal = sma_signal == 'SMA' ? ta.sma(macd, signal_length) : ta.ema(macd, signal_length)

macdUP = ta.crossover(macd, signal)
macdDOWN = ta.crossunder(macd, signal)
// } End of MACD

// Moving Averages {
smoothing_type = input.string(title='Average type', defval='SMA', options=['EMA', 'SMA', 'WMA', 'VWMA', 'HMA', 'RMA', 'DEMA'], inline='movingaverage', group='if Moving Average selected')
ma_length = input.int(20, title='Length', inline='movingaverage', group='if Moving Average selected')
moving_average(_series, _length, _smoothing) =>
    _smoothing == 'EMA' ? ta.ema(_series, _length) : _smoothing == 'SMA' ? ta.sma(_series, _length) : _smoothing == 'WMA' ? ta.wma(_series, _length) : _smoothing == 'VWMA' ? ta.vwma(_series, _length) : _smoothing == 'HMA' ? ta.hma(_series, _length) : _smoothing == 'RMA' ? ta.rma(_series, _length) : _smoothing == 'DEMA' ? 2 * ta.ema(_series, _length) - ta.ema(ta.ema(_series, _length), _length) : ta.ema(_series, _length)
movingaverage = moving_average(close, ma_length, smoothing_type)
maUP = movingaverage > movingaverage[1] and movingaverage[2] > movingaverage[1]
maDOWN = movingaverage < movingaverage[1] and movingaverage[2] < movingaverage[1]
// } End of Moving Averages


// QQE {
RSI_Period = input.int(14, title='RSI Length', inline='qqe', group='if QQE selected')
qqeslow = input.float(4.238, title='QQE Factor', inline='qqe', group='if QQE selected')
SFslow = input.int(5, title='RSI Smoothing', inline='qqe', group='if QQE selected')
ThreshHold = input.int(10, title='Thresh-hold', inline='qqe', group='if QQE selected')
rsi_currenttf = ta.rsi(close, RSI_Period)

qqenew(_qqefactor, _smoothingfactor, _rsi, _threshold, _RSI_Period) =>
    RSI_Period = _RSI_Period
    SF = _smoothingfactor
    QQE = _qqefactor
    ThreshHold = _threshold
    Wilders_Period = RSI_Period * 2 - 1
    Rsi = _rsi
    RsiMa = ta.ema(Rsi, SF)
    AtrRsi = math.abs(RsiMa[1] - RsiMa)
    MaAtrRsi = ta.ema(AtrRsi, Wilders_Period)
    dar = ta.ema(MaAtrRsi, Wilders_Period) * QQE
    longband = 0.0
    shortband = 0.0
    trend = 0
    DeltaFastAtrRsi = dar
    RSIndex = RsiMa
    newshortband = RSIndex + DeltaFastAtrRsi
    newlongband = RSIndex - DeltaFastAtrRsi
    longband := RSIndex[1] > longband[1] and RSIndex > longband[1] ? math.max(longband[1], newlongband) : newlongband
    shortband := RSIndex[1] < shortband[1] and RSIndex < shortband[1] ? math.min(shortband[1], newshortband) : newshortband
    QQExlong = 0
    QQExlong := nz(QQExlong[1])
    QQExshort = 0
    QQExshort := nz(QQExshort[1])
    qqe_goingup = ta.barssince(QQExlong == 1) < ta.barssince(QQExshort == 1)
    qqe_goingdown = ta.barssince(QQExlong == 1) > ta.barssince(QQExshort == 1)
    var float last_qqe_high = high
    var float last_qqe_low = low
    last_qqe_high := high > last_qqe_high[1] and qqe_goingup or qqe_goingdown[1] and qqe_goingup ? high : nz(last_qqe_high[1])
    last_qqe_low := low < last_qqe_low[1] and qqe_goingdown or qqe_goingup[1] and qqe_goingdown ? low : nz(last_qqe_low[1])
    trend := ta.crossover(RSIndex, shortband[1]) or ta.crossover(high, last_qqe_high) ? 1 : ta.crossunder(RSIndex, longband[1]) or ta.crossunder(low, last_qqe_low) ? -1 : nz(trend[1], 1)
    FastAtrRsiTL = trend == 1 ? longband : shortband
    // Find all the QQE Crosses
    QQExlong := trend == 1 and trend[1] == -1 ? QQExlong + 1 : 0
    QQExshort := trend == -1 and trend[1] == 1 ? QQExshort + 1 : 0
    qqeLong = QQExlong == 1 ? FastAtrRsiTL[1] - 50 : na
    qqeShort = QQExshort == 1 ? FastAtrRsiTL[1] - 50 : na
    qqenew = qqeLong ? 1 : qqeShort ? -1 : na
    qqenew

qqeUP = qqenew(qqeslow, SFslow, rsi_currenttf, ThreshHold, RSI_Period) == 1
qqeDOWN = qqenew(qqeslow, SFslow, rsi_currenttf, ThreshHold, RSI_Period) == -1
// } End of QQE


momentumUP = momentum_select == 'MACD' ? macdUP : momentum_select == 'MovingAverage' ? maUP : momentum_select == 'QQE' ? qqeUP : qqeUP

momentumDOWN = momentum_select == 'MACD' ? macdDOWN : momentum_select == 'MovingAverage' ? maDOWN : momentum_select == 'QQE' ? qqeDOWN : qqeDOWN

momentum_direction := momentumUP ? 1 : momentumDOWN ? -1 : nz(momentum_direction[1])

// { Force detection
rsi5 = ta.rsi(close, 5)
ob = 80
os = 20
barssince_momentumUP = ta.barssince(momentumUP)
barssince_momentumDOWN = ta.barssince(momentumDOWN)
momentum_DOWN_was_force_up = momentumDOWN and (barssince_momentumUP >= ta.barssince(rsi5 > ob))[1]
momentum_UP_was_force_down = momentumUP and (barssince_momentumDOWN >= ta.barssince(rsi5 < os))[1]
zzcolor_rsi5 = momentum_DOWN_was_force_up ? color.lime : momentum_UP_was_force_down ? color.red : color.black
// } End of Force detection


ZigZag = zigzag(momentum_direction)
plot(ZigZag, linewidth=5, color=color_zigzag_lines ? zzcolor_rsi5 : color.black, title='ZIGZAG', style=plot.style_line, transp=0)

GoShort = momentumDOWN and not momentum_DOWN_was_force_up
GoLong = momentumUP and not momentum_UP_was_force_down

if GoShort
    label.new(bar_index, ZigZag, style=label.style_label_down, color=color.red, text=str.tostring('SHORT\n\npivot high: \n' + str.tostring(ZigZag)))
if GoLong
    label.new(bar_index, ZigZag, style=label.style_label_up, color=color.lime, text=str.tostring('LONG\n\npivot low: \n' + str.tostring(ZigZag)))


var float stoploss_long = low
var float stoploss_short = high

pl = ta.valuewhen(momentumUP, ZigZag, 0)
ph = ta.valuewhen(momentumDOWN, ZigZag, 0)

if GoLong
    stoploss_long := low < pl ? low : pl
    stoploss_long
if GoShort
    stoploss_short := high > ph ? high : ph
    stoploss_short

TakeProfitLevel=input(200)


// Function: Modified MTF Relative Strength Index
f_rsi(_src, _len, _mtf, _type)=>

    _change = _src - _src[_mtf]
    
    _up = math.max(_change, 0)
    _down = (-math.min(_change, 0))
    
    _up_change = _type == "Wilders" ? ta.rma(_up, (_len * _mtf)) :
                 _type == "Cutlers" ? ta.sma(_up, (_len * _mtf)) : na

    _down_change = _type == "Wilders" ? ta.rma(_down, (_len * _mtf)) :
                   _type == "Cutlers" ? ta.sma(_down, (_len * _mtf)) : na
    
    _rsi = _down_change == 0 ? 100 : 
           _up_change == 0 ? 0 : 
           100 - (100 / (1 + _up_change / _down_change))

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// Function: ZigZag
f_zz(_dir, _high, _low)=>

    _up = _dir == 1
    _down = _dir == -1
    
    _peak = 0.0
    _peak := _high > _peak[1] and _up or _down[1] and _up ? _high : 
             nz(_peak[1])

    _bottom = 0.0
    _bottom := _low < _bottom[1] and _down or _up[1] and _down ? _low : 
               nz(_bottom[1])

    _zz = _up and _down[1] ? _bottom[1] : 
          _up[1] and _down ? _peak[1] : na
    _top = _down and _up[1] ? _peak[1] : na
    _bot = _up and _down[1] ? _bottom[1] : na
    [_zz, _top, _bot]

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// Function: Modified QQE 
f_qqe(_len, _mtf, _type, _smooth, _atr_mult)=>
    
    _wilders =  _len * 2 - 1 
    
    _up = 0.0
    _up_rsi = f_rsi(low, _len, _mtf, _type)
    _up_ema = ta.ema(_up_rsi, _smooth)
    _up_atr = math.abs(_up_ema[1] - _up_ema)
    _up_diff = ta.ema(ta.ema(_up_atr, _wilders), _wilders) * _atr_mult
    _up_ma = _up_ema - _up_diff
    _up := _up_ema[1] > _up[1] and _up_ema > _up[1] ? math.max(_up_ma, _up[1]) : _up_ma
    
    _dn = 0.0
    _dn_rsi = f_rsi(high, _len, _mtf, _type)
    _dn_ema = ta.ema(_dn_rsi, _smooth)
    _dn_atr = math.abs(_dn_ema[1] - _dn_ema)
    _dn_diff = ta.ema(ta.ema(_dn_atr, _wilders), _wilders) * _atr_mult
    _dn_ma = _dn_ema + _dn_diff
    _dn := _dn_ema[1] < _dn[1] and _dn_ema < _dn[1] ? math.min(_dn_ma, _dn[1]) : _dn_ma
    
    _trend = 0
    _trend := ta.crossover(_dn_ema, _dn[1]) ? 1 : 
              ta.crossunder(_up_ema, _up[1]) ? -1 : 
              nz(_trend[1], _trend)

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// Function: Supertrend
f_supertrend(_top, _bot, _incl, _len, _type, _atr_len, _atr_mult)=>
    
    _atr = ta.atr(_atr_len) * _atr_mult
    
    _up_ma = _type == "EMA" ? ta.ema(low[1], _len) : 
             _type == "SMA" ? ta.sma(low[1], _len) : 
             _type == "HH / LL" ? ta.lowest(low[1], _len) : na
    _up_b = _incl ? _bot[1] - _atr : na
    _up = _up_ma - _atr
    _up := low[1] > _up[1] ? math.max(_up, _up[1], nz(_up_b, _up - 1)) : _up
    
    _dn_ma = _type == "EMA" ? ta.ema(high[1], _len) : 
             _type == "SMA" ? ta.sma(high[1], _len) : 
             _type == "HH / LL" ? ta.highest(high[1], _len) : na
    _dn_t = _incl ? _top[1] + _atr : na
    _dn = _dn_ma + _atr
    _dn := high[1] < _dn[1] ? math.min(_dn, _dn[1], nz(_dn_t, _dn + 1)) : _dn
    
    _trend = 0
    _trend := ta.crossover(high[1], _dn[1]) ? 1 :
              ta.crossunder(low[1], _up[1]) ? -1 :
              nz(_trend[1], _trend)
    [_trend, _up, _dn]

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// Calc: Rsi QQE ZigZag 
qqe_trend = f_qqe(r1_len, r1_mtf, r1_type, r1_smooth, r1_mult)
[zz, zz_top, zz_bot] = f_zz(qqe_trend, high, low)
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//

// Calc: Supertrend
[s_trend, s_up, s_dn] = f_supertrend(zz_top, zz_bot, s1_incl, s1_len, s1_type, s1_atr_len, s1_atr_mult)

st_up = s_trend == 1 and trendOn? s_up : na
st_dn = s_trend == -1 and trendOn? s_dn : na


//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------//
// Draw: Supertrend
plot(s1_show ? st_up : na, title = "Up-Trend", color = s1_bull, linewidth = s1_line, editable = true, style = plot.style_linebr)
plot(s1_show ? st_dn : na, title = "Down-Trend", color = s1_bear, linewidth = s1_line, editable = true, style = plot.style_linebr)


// 开仓时的止损和止盈价位，并存储在变量中
long_stop_loss = ta.lowest(lowest) //5根K线内最低价
long_take_profit = ((close - long_stop_loss) * RRR) + close 
var long_stop_loss_initial = 0.0
var long_take_profit_initial = 0.0
// 多头开单
if trendOn 
    if GoLong and st_up and longOn 
        // 在开仓时存储止损和止盈价位 bar_index
        long_stop_loss_initial := long_stop_loss
        long_take_profit_initial := long_take_profit
        strategy.entry('long',strategy.long)
        strategy.exit("平仓", "long",stop=long_stop_loss_initial, comment_loss="long 止损")
else
    if GoLong and longOn 
        // 在开仓时存储止损和止盈价位 bar_index
        long_stop_loss_initial := long_stop_loss
        long_take_profit_initial := long_take_profit
        strategy.entry('long',strategy.long)
        strategy.exit("平仓", "long",stop=long_stop_loss_initial, comment_loss="long 止损")
if GoShort or st_dn
    strategy.close("long", comment="多头趋势结束 止损")
pivotsizing = 20 //length
pivotLookup = 1
L_TP = long_take_profit_initial
hih     = ta.pivothigh(high, pivotLookup, pivotLookup)
top     = ta.valuewhen(hih, high[pivotLookup], 0)
float highest = ta.highest(top,pivotsizing)
moveHigh = ta.crossunder(close,highest*(1 - long_Ts2))
L_reversal = ta.crossunder(close,L_TP)

if close > L_TP and moveHigh and strategy.position_size > 0
    strategy.close_all(comment = "多头趋势止盈")
else if close > L_TP and L_reversal and strategy.position_size > 0
    strategy.close_all(comment = "多头趋势不明显保护性止盈")

// 开仓时的止损和止盈价位，并存储在变量中
short_stop_loss = ta.highest(lowest) //5根K线内最高价
short_take_profit = close - ((short_stop_loss - close) * RRR)  //计算止盈位
var short_stop_loss_initial = 0.0
var short_take_profit_initial = 0.0
// 空头开单
if trendOn 
    if GoShort and st_dn and shortOn 
        // 在开仓时存储止损和止盈价位 bar_index
        short_stop_loss_initial := short_stop_loss
        short_take_profit_initial := short_take_profit
        strategy.entry('short',strategy.short)
        strategy.exit("平仓", "short",stop=short_stop_loss_initial, comment_loss="short 止损")
else
    if GoShort and shortOn 
        // 在开仓时存储止损和止盈价位 bar_index
        short_stop_loss_initial := short_stop_loss
        short_take_profit_initial := short_take_profit
        strategy.entry('short',strategy.short)
        strategy.exit("平仓", "short",stop=short_stop_loss_initial, comment_loss="short 止损")
if GoLong or st_up
    strategy.close("short", comment="空头趋势结束 止损")
S_TP = short_take_profit_initial
bot     = ta.pivotlow(low, pivotLookup, pivotLookup)
bottom     = ta.valuewhen(bot, low[pivotLookup], 0)
float bottomst = ta.lowest(bottom,pivotsizing)
moveBottom = ta.crossunder(close,bottomst*(1 - short_Ts2))
S_reversal = ta.crossunder(close,S_TP)

if close < L_TP and moveBottom and strategy.position_size < 0
    strategy.close_all(comment = "空头趋势止盈")
else if close < L_TP and S_reversal and strategy.position_size < 0
    strategy.close_all(comment = "空头趋势不明显保护性止盈")


// 在每个周期结束时，检查订单状态并更新止损和止盈价位
if strategy.position_size == 0
    long_stop_loss_initial := long_stop_loss
    long_take_profit_initial := long_take_profit
    short_stop_loss_initial := short_stop_loss
    short_take_profit_initial := short_take_profit