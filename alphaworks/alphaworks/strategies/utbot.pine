//@version=6
strategy(title = 'Alpha UT 多空引擎 v3.0', overlay = true, initial_capital = 1000, default_qty_type = strategy.percent_of_equity, default_qty_value = 100, commission_type = strategy.commission.percent, commission_value = 0.04)

// 用户输入：设置止损百分比、启用开关
stopLossPercent = input.float(5.0, title = '固定止损%', minval = 0.1, step = 0.1)
useAtrStop = input.bool(true, title = '使用 ATR 止损')
atrStopMultiplier = input.float(2.5, title = 'ATR 止损倍数', minval = 0.1, step = 0.1)
// 移动止盈开始点位
moveStopProfitStartPercent = input.float(3.0, title = '移动止盈开始点位%', minval = 0.1, step = 0.1)
profitCallbackPercent = input.float(30.0, title = '盈利回调出场%', minval = 0.1, step = 0.1)

// 用户输入：策略其他参数
EEEEEE = input(80, title = 'STC 长度')
BBBB = input(26, title = '快速 EMA 长度')
BBBBB = input(50, title = '慢速 EMA 长度')
AAA = input.float(0.5, title = 'STC 平滑因子', minval = 0.01, maxval = 1)

useStcFilter = input.bool(true, title = '启用 STC 过滤')
useQqeFilter = input.bool(true, title = '启用 QQE 过滤')
filterRequireBoth = input.bool(false, title = '多头过滤需同时满足')
enableShortTrading = input.bool(false, title = '启用做空交易')
stcBullThreshold = input.float(30.0, title = 'STC 多头阈值', minval = 0, maxval = 100)
stcBearThreshold = input.float(70.0, title = 'STC 空头阈值', minval = 0, maxval = 100)

// === PRIMARY QQE SETTINGS ===
group_primary = "Primary QQE Settings"
rsiLengthPrimary = input.int(6, title="RSI Length", group=group_primary)
rsiSmoothingPrimary = input.int(5, title="RSI Smoothing", group=group_primary)
qqeFactorPrimary = input.float(3.0, title="QQE Factor", group=group_primary)
sourcePrimary = input.source(close, title="RSI Source", group=group_primary)

// === SECONDARY QQE SETTINGS ===
group_secondary = "Secondary QQE Settings"
rsiLengthSecondary = input.int(6, title="RSI Length", group=group_secondary)
rsiSmoothingSecondary = input.int(5, title="RSI Smoothing", group=group_secondary)
qqeFactorSecondary = input.float(1.61, title="QQE Factor", group=group_secondary)
thresholdSecondary = input.float(3.0, title="Threshold", group=group_secondary)
sourceSecondary = input.source(close, title="RSI Source", group=group_secondary)

// === BOLLINGER BANDS SETTINGS ===
group_bollinger = "Bollinger Bands Settings"
bollingerLength = input.int(50, minval=1, title="Length", group=group_bollinger, tooltip="The length of the Bollinger Bands calculation.")
bollingerMultiplier = input.float(0.35, step=0.1, minval=0.001, maxval=5, title="Multiplier", group=group_bollinger, tooltip="The multiplier used to calculate Bollinger Band width.")

// 定义辅助函数
AAAA(BBB, BBBB, BBBBB) =>
    fastMA = ta.ema(BBB, BBBB)
    slowMA = ta.ema(BBB, BBBBB)
    fastMA - slowMA

AAAAA(EEEEEE, BBBB, BBBBB) =>
    var CCCCC = 0.0
    var DDD = 0.0
    var DDDDDD = 0.0
    var EEEEE = 0.0
    BBBBBB = AAAA(close, BBBB, BBBBB)
    CCC = ta.lowest(BBBBBB, EEEEEE)
    CCCC = ta.highest(BBBBBB, EEEEEE) - CCC
    CCCCC := CCCC > 0 ? (BBBBBB - CCC) / CCCC * 100 : nz(CCCCC[1])
    DDD := na(DDD[1]) ? CCCCC : DDD[1] + AAA * (CCCCC - DDD[1])
    DDDD = ta.lowest(DDD, EEEEEE)
    DDDDD = ta.highest(DDD, EEEEEE) - DDDD
    DDDDDD := DDDDD > 0 ? (DDD - DDDD) / DDDDD * 100 : nz(DDDDDD[1])
    EEEEE := na(EEEEE[1]) ? DDDDDD : EEEEE[1] + AAA * (DDDDDD - EEEEE[1])
    EEEEE

// 计算 STC 值
mAAAAA = AAAAA(EEEEEE, BBBB, BBBBB)

// 输入与计算指标
a = input(3, title = '关键值（影响敏感度）')
c = input(1, title = 'ATR 周期')
h = input(false, title = '是否使用 HeikinAshi 蜡烛图信号')

xATR = ta.atr(c)
nLoss = a * xATR

src = h ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close, lookahead = barmerge.lookahead_off) : close

xATRTrailingStop = 0.0
iff_1 = src > nz(xATRTrailingStop[1], 0) ? src - nLoss : src + nLoss
iff_2 = src < nz(xATRTrailingStop[1], 0) and src[1] < nz(xATRTrailingStop[1], 0) ? math.min(nz(xATRTrailingStop[1]), src + nLoss) : iff_1
xATRTrailingStop := src > nz(xATRTrailingStop[1], 0) and src[1] > nz(xATRTrailingStop[1], 0) ? math.max(nz(xATRTrailingStop[1]), src - nLoss) : iff_2

ema = ta.ema(src, 1)
above = ta.crossover(ema, xATRTrailingStop)
below = ta.crossover(xATRTrailingStop, ema)

// === FUNCTIONS ===
// Calculate QQE Bands
calculateQQE(rsiLength, smoothingFactor, qqeFactor, source) =>
    wildersLength = rsiLength * 2 - 1
    rsi = ta.rsi(source, rsiLength)
    smoothedRsi = ta.ema(rsi, smoothingFactor)
    atrRsi = math.abs(smoothedRsi[1] - smoothedRsi)
    smoothedAtrRsi = ta.ema(atrRsi, wildersLength)
    dynamicAtrRsi = smoothedAtrRsi * qqeFactor

    // Initialize variables
    longBand = 0.0
    shortBand = 0.0
    trendDirection = 0

    // Calculate longBand, shortBand, and trendDirection
    atrDelta = dynamicAtrRsi
    newShortBand = smoothedRsi + atrDelta
    newLongBand = smoothedRsi - atrDelta
    longBand := smoothedRsi[1] > longBand[1] and smoothedRsi > longBand[1] ? math.max(longBand[1], newLongBand) : newLongBand
    shortBand := smoothedRsi[1] < shortBand[1] and smoothedRsi < shortBand[1] ? math.min(shortBand[1], newShortBand) : newShortBand
    longBandCross = ta.cross(longBand[1], smoothedRsi)
    
    if ta.cross(smoothedRsi, shortBand[1])
        trendDirection := 1
    else if longBandCross
        trendDirection := -1
    else
        trendDirection := trendDirection[1]

    // Determine the trend line
    qqeTrendLine = trendDirection == 1 ? longBand : shortBand
    [qqeTrendLine, smoothedRsi]

// === MAIN CALCULATIONS ===
// Calculate Primary QQE
[primaryQQETrendLine, primaryRSI] = calculateQQE(rsiLengthPrimary, rsiSmoothingPrimary, qqeFactorPrimary, sourcePrimary)

// Calculate Secondary QQE
[secondaryQQETrendLine, secondaryRSI] = calculateQQE(rsiLengthSecondary, rsiSmoothingSecondary, qqeFactorSecondary, sourceSecondary)

// Calculate Bollinger Bands for the Primary QQE Trend Line
bollingerBasis = ta.sma(primaryQQETrendLine - 50, bollingerLength)
bollingerDeviation = bollingerMultiplier * ta.stdev(primaryQQETrendLine - 50, bollingerLength)
bollingerUpper = bollingerBasis + bollingerDeviation
bollingerLower = bollingerBasis - bollingerDeviation

// Color Conditions for Secondary RSI
rsiColorSecondary = secondaryRSI - 50 > thresholdSecondary ? color.new(#707070, 20) : secondaryRSI - 50 < -thresholdSecondary ? color.new(#707070, 20) : na

// === PLOTTING ===
// Plot Primary and Secondary QQE Lines
// plot(secondaryQQETrendLine - 50, title="Secondary QQE Trend Line", color=color.white, linewidth=2)
// plot(secondaryRSI - 50, color=rsiColorSecondary, title="Secondary RSI Histogram", style=plot.style_columns)

// Plot Signal Highlights
// plot(secondaryRSI - 50 > thresholdSecondary and primaryRSI - 50 > bollingerUpper ? secondaryRSI - 50 : na, title="QQE Up Signal", style=plot.style_columns, color=#00c3ff)
// plot(secondaryRSI - 50 < -thresholdSecondary and primaryRSI - 50 < bollingerLower ? secondaryRSI - 50 : na, title="QQE Down Signal", style=plot.style_columns, color=#ff0062)

stcUpSignal = ta.crossover(mAAAAA, stcBullThreshold)
stcDownSignal = ta.crossunder(mAAAAA, stcBearThreshold)

qqeUpSignal = secondaryRSI - 50 > thresholdSecondary and primaryRSI - 50 > bollingerUpper
qqeDownSignal = secondaryRSI - 50 < -thresholdSecondary and primaryRSI - 50 < bollingerLower

utUpSignal = src > xATRTrailingStop and above
utDownSignal = src < xATRTrailingStop and below

filtersDisabled = not useStcFilter and not useQqeFilter
longFilterPass = filtersDisabled ? true : filterRequireBoth ? ((not useStcFilter or stcUpSignal) and (not useQqeFilter or qqeUpSignal)) : ((useStcFilter and stcUpSignal) or (useQqeFilter and qqeUpSignal))
shortFilterPass = filtersDisabled ? true : filterRequireBoth ? ((not useStcFilter or stcDownSignal) and (not useQqeFilter or qqeDownSignal)) : ((useStcFilter and stcDownSignal) or (useQqeFilter and qqeDownSignal))
filterEnabled = not filtersDisabled
longFilterExit = filterEnabled and shortFilterPass
shortFilterExit = filterEnabled and longFilterPass

longEntrySignal = utUpSignal and longFilterPass
longExitSignal = utDownSignal or longFilterExit
shortEntrySignal = enableShortTrading and utDownSignal and shortFilterPass
shortExitSignal = (enableShortTrading or strategy.position_size < 0) and (utUpSignal or shortFilterExit)

activeLongExit = longExitSignal and strategy.position_size > 0
activeShortExit = shortExitSignal and strategy.position_size < 0

plotshape(longEntrySignal, title = '买入', text = '买', style = shape.labelup, location = location.belowbar, color = color.new(color.green, 0), textcolor = color.new(color.white, 0), size = size.tiny)
plotshape(shortEntrySignal, title = '做空', text = '空', style = shape.labeldown, location = location.abovebar, color = color.new(color.purple, 0), textcolor = color.new(color.white, 0), size = size.tiny)
plotshape(activeLongExit, title = '平多', text = '平多', style = shape.labeldown, location = location.abovebar, color = color.new(color.red, 0), textcolor = color.new(color.white, 0), size = size.tiny)
plotshape(activeShortExit, title = '平空', text = '平空', style = shape.labelup, location = location.belowbar, color = color.new(color.orange, 0), textcolor = color.new(color.white, 0), size = size.tiny)

// 平仓逻辑
if activeLongExit
    strategy.close('long', comment = '平多')
if activeShortExit
    strategy.close('short', comment = '平空')

// 开仓逻辑
if longEntrySignal
    strategy.entry('long', strategy.long)
if shortEntrySignal
    strategy.entry('short', strategy.short)
longPosition = strategy.position_size > 0
shortPosition = strategy.position_size < 0
longEntryPrice = longPosition ? strategy.position_avg_price : na
shortEntryPrice = shortPosition ? strategy.position_avg_price : na

// 记录入场时的 ATR，用于波动止损
var float atrAtLongEntry = na
var float atrAtShortEntry = na
if longPosition
    atrAtLongEntry := strategy.position_size[1] <= 0 ? xATR : nz(atrAtLongEntry, xATR)
else
    atrAtLongEntry := na

if shortPosition
    atrAtShortEntry := strategy.position_size[1] >= 0 ? xATR : nz(atrAtShortEntry, xATR)
else
    atrAtShortEntry := na

// 多头止损与移动止盈
percentStopLong = not na(longEntryPrice) ? longEntryPrice * (1 - 0.01 * stopLossPercent) : na
atrStopLong = not na(longEntryPrice) and not na(atrAtLongEntry) ? longEntryPrice - atrAtLongEntry * atrStopMultiplier : na
stopLossPriceLong = useAtrStop and not na(atrStopLong) ? atrStopLong : percentStopLong
moveStopStartLong = not na(longEntryPrice) ? longEntryPrice * (1 + 0.01 * moveStopProfitStartPercent) : na

var bool trailingStopSwitchLong = false
var float highestCloseSinceEntryLong = na
var float movingTargetPriceLong = na

if longPosition and not na(longEntryPrice)
    highestCloseSinceEntryLong := na(highestCloseSinceEntryLong) ? close : math.max(highestCloseSinceEntryLong, close)
    if not trailingStopSwitchLong and not na(moveStopStartLong) and close >= moveStopStartLong
        trailingStopSwitchLong := true
    if trailingStopSwitchLong
        movingTargetPriceLong := longEntryPrice + (highestCloseSinceEntryLong - longEntryPrice) * (1 - 0.01 * profitCallbackPercent)
else
    trailingStopSwitchLong := false
    highestCloseSinceEntryLong := na
    movingTargetPriceLong := na

if longPosition and not na(stopLossPriceLong)
    strategy.exit('止损或止盈_多', 'long', stop = trailingStopSwitchLong and not na(movingTargetPriceLong) ? movingTargetPriceLong : stopLossPriceLong)

// 空头止损与移动止盈
percentStopShort = not na(shortEntryPrice) ? shortEntryPrice * (1 + 0.01 * stopLossPercent) : na
atrStopShort = not na(shortEntryPrice) and not na(atrAtShortEntry) ? shortEntryPrice + atrAtShortEntry * atrStopMultiplier : na
stopLossPriceShort = useAtrStop and not na(atrStopShort) ? atrStopShort : percentStopShort
moveStopStartShort = not na(shortEntryPrice) ? shortEntryPrice * (1 - 0.01 * moveStopProfitStartPercent) : na

var bool trailingStopSwitchShort = false
var float lowestCloseSinceEntryShort = na
var float movingTargetPriceShort = na

if shortPosition and not na(shortEntryPrice)
    lowestCloseSinceEntryShort := na(lowestCloseSinceEntryShort) ? close : math.min(lowestCloseSinceEntryShort, close)
    if not trailingStopSwitchShort and not na(moveStopStartShort) and close <= moveStopStartShort
        trailingStopSwitchShort := true
    if trailingStopSwitchShort
        movingTargetPriceShort := shortEntryPrice - (shortEntryPrice - lowestCloseSinceEntryShort) * (1 - 0.01 * profitCallbackPercent)
else
    trailingStopSwitchShort := false
    lowestCloseSinceEntryShort := na
    movingTargetPriceShort := na

if shortPosition and not na(stopLossPriceShort)
    strategy.exit('止损或止盈_空', 'short', stop = trailingStopSwitchShort and not na(movingTargetPriceShort) ? movingTargetPriceShort : stopLossPriceShort)
